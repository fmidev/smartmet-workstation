// k10/extsortq.h   as extsort.h but with priority_queue
// changes:  split(), some headers, a new typedef in
//           class SubsequenceIterator and its use
#ifndef EXTSORTQ_H
#define EXTSORTQ_H

#include<fstream>
#include<iterator>
#include<vector>
#include<queue>

using namespace std;

template<class T, class Compare>
class SubsequenceIterator : public istream_iterator<T>
{
  public:
    typedef T value_type;          // public types
    typedef Compare compare_type;  // used below

    SubsequenceIterator()
    : comp(Compare())
    {}

    SubsequenceIterator(istream& is, const Compare& c)
    : istream_iterator<T>(is),
      comp(c), sorted_(true),
      previousValue(istream_iterator<T>::operator*())
    {}

    /* previousValue can be initialized with a value, because the
       initialization of the base class subobject has already read 
       something. The ++ operators following now ensure that the end of a
       sorted subsequence is recognized by setting the private
       variable sorted_. A subsequence is in any case also closed when
       the stream is terminated; this is checked by comparing the
       SubsequenceIterator object itself (i.e. *this) to an end-iterator
       generated by the default constructor.
     . It is important to write !comp(previousValue, value) and
       not comp(value, previousValue). The second notation would
       erroneously already signal the end of a subsequence when two
       equal elements follow each other. You can easily imagine this
       by assuming, for example, Compare = less<int>. */

    SubsequenceIterator& operator++()
    {
        istream_iterator<T>::operator++();
        const T& value =  istream_iterator<T>::operator*();
        sorted_ =  !comp(previousValue, value)  // correct order
              && *this != SubsequenceIterator<T, Compare>(); // end not yet reached
        previousValue = value;
        return *this;
    }

    SubsequenceIterator operator++(int)
    {
        SubsequenceIterator tmp = *this;
        operator++();
        return tmp;
    }

    bool sorted() const { return sorted_;}

    /* When the end of a subsequence was recognized, the internal flag
       for this can be reset with nextSubsequence() in order to
       process the next subsequence (if there is one): */

    void nextSubsequence()
    {
        sorted_ = (*this != SubsequenceIterator<T, Compare>());
    }

    Compare Compareobject() const { return comp;}

    /* Compareobject() supplies a copy of the internal comp object. In
       addition to the inherited variables, the following ones are
       needed: */

  private:
    Compare comp;
    bool sorted_;
    T previousValue;
};


// SubSeqIterator is a placeholder for the data type of a subsequence iterator.
template<class SubSeqIterator>
void split(SubSeqIterator& InputIterator,
           const char *Filename1,
           const char *Filename2,
           bool& sorted)
{
    typedef typename SubSeqIterator::value_type value_type;
    typedef typename SubSeqIterator::compare_type Compare;

    const size_t maxSize = 30000; // maximize, see text

    // The size of the priority queue is dynamically increased 
    // up to the given limit (see below)
    priority_queue<value_type, vector<value_type>, Compare>
                 PQ(InputIterator.Compareobject());

    ofstream Target1(Filename1);
    ofstream Target2(Filename2);
    ostream_iterator<value_type> Output1(Target1, "\n");
    ostream_iterator<value_type> Output2(Target2, "\n");
    SubSeqIterator End;

    sorted = true;
    bool flipflop = true;        // for switching the output

    while(InputIterator != End)
    {
        // fill priority queue
        while(InputIterator != End && PQ.size() < maxSize)
        {
           if(!InputIterator.sorted())
              sorted = false;
           PQ.push(*InputIterator++);
        }

        while(!PQ.empty())
        {
            // Write to output files. Selection of file 
            // by way of the variable flipflop}
            if(flipflop) *Output1++ =  PQ.top();
            else         *Output2++ =  PQ.top();

            // create space and fill if needed
            PQ.pop();
            if(InputIterator != End)
            {
              if(!InputIterator.sorted())
                  sorted = false;

              // The next element is only inserted if it does not
              // violate the subsequence ordering.
              if(!InputIterator.Compareobject()(PQ.top(), *InputIterator))
                 PQ.push(*InputIterator++);
            }
        }

        /* The priority queue is now empty; the sorted sequence 
           output is terminated. For outputting the next sorted
           sequence we switch to the next channel. */
        flipflop = !flipflop;
    }
}

/* After splitting a file into two temporary auxiliary files, the file
   is rebuilt on a `higher sorting level' by merging the auxiliary
   files.*/

template <class SubsequenceIterator, class OutputIterator,
          class Compare>
void mergeSubsequences(SubsequenceIterator first1,
                       SubsequenceIterator last1,
                       SubsequenceIterator first2,
                       SubsequenceIterator last2,
                       OutputIterator result,
                       const Compare& comp)

{
    // as long as not both the auxiliary files are exhausted
    while (first1 != last1 && first2 != last2)
    {
        // merge sorted subsequences
        while(first1.sorted() && first2.sorted())
             if (comp(*first1, *first2))
                 *result++ = *first2++;
             else
                 *result++ = *first1++;

        // At this point, (at least) one of the subsequences is terminated.
        // Now copy the rest of the other subsequence:
        while(first1.sorted()) *result++ = *first1++;
        while(first2.sorted()) *result++ = *first2++;

        // Process the next subsequence in both auxiliary files,
        // provided there is one:
        first1.nextSubsequence();
        first2.nextSubsequence();
    }

    // At least one of the temporary files is exhausted. 
    // Copy the rest of the other one:
    copy(first1, last1, result);
    copy(first2, last2, result);
}

/* Next, the function externalSorting() follows, which constitutes the
   user interface in a main() program. This function calls an
   overloaded function of the same name which differs by two pointers
   in the parameter list. These pointers are exclusively used to
   determine the type of the values contained in the file and the
   suitable distance type. */

template<class IstreamIterator, class Compare>
int externalSorting(IstreamIterator& InputIterator,
                    const char *SortFilename,
                    const char *Separator,
                    const Compare& comp)
{
    typedef iterator_traits<IstreamIterator>::value_type valueType; 
    bool sorted = false;

    // arbitrary names for auxiliary files
    char *TempFile1 = "esort001.tmp", 
         *TempFile2 = "esort002.tmp";

    int Run = 0;       // number of sort-merge cycles
    do
    {
       ifstream Inputfile(SortFilename);
       SubsequenceIterator<valueType, Compare>
                      FileIterator(Inputfile, comp);

       /* The file to be sorted must exist. A suitable subsequence
          iterator for reading  is passed to the function split()
          which writes sorted subsequences of the main file into two
          auxiliary files. */

       split(FileIterator, TempFile1, TempFile2, sorted);
       Inputfile.close();

       /* During this process, split()} determines whether the input
          is already sorted. Only if this is not the case, are further
          steps necessary. These steps consist in generating
          subsequence iterators for the function mergeSubsequences()
          and opening the output file. Then, the subsequences are
          merged. */

       if(!sorted)
       {
          // prepare for merging
          ifstream Source1(TempFile1);
          ifstream Source2(TempFile2);

          SubsequenceIterator<valueType, Compare> I1(Source1, comp);
          SubsequenceIterator<valueType, Compare> I2(Source2, comp);
          SubsequenceIterator<valueType, Compare> End;

          // open sort file for writing
          ofstream Output(SortFilename);
          ostream_iterator<valueType> Result(Output, Separator);

          mergeSubsequences(I1, End, I2, End, Result, comp);
          ++Run;
       }
    } while(!sorted);
    return Run;
}


#endif

