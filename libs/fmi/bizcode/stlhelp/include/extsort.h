// k10/extsort.h
#ifndef EXTSORT_H
#define EXTSORT_H

#include<fstream>
#include<algorithm>
#include<iterator>  

using namespace std;

template<class T, class Compare>
class SubsequenceIterator : public istream_iterator<T>
{
  public:
    typedef T value_type;  // public type
    SubsequenceIterator()
    : comp(Compare())
    {}

    SubsequenceIterator(istream& is, const Compare& c)
    : istream_iterator<T>(is),
      comp(c), sorted_(true),
      previousValue(istream_iterator<T>::operator*())
    {}

    /* previousValue can be initialized with a value, because the
       initialization of the base class subobject has already read 
       something. The ++ operators following now ensure that the end of a
       sorted subsequence is recognized by setting the private
       variable sorted_. A subsequence is in any case also closed when
       the stream is terminated; this is checked by comparing the
       SubsequenceIterator object itself (i.e. *this) to an end-iterator
       generated by the default constructor.
     . It is important to write !comp(previousValue, value) and
       not comp(value, previousValue). The second notation would
       erroneously already signal the end of a subsequence when two
       equal elements follow each other. You can easily imagine this
       by assuming, for example, Compare = less<int>. */

    SubsequenceIterator& operator++()
    {
        istream_iterator<T>::operator++();
        const T& value =  istream_iterator<T>::operator*();
        sorted_ =  !comp(previousValue, value)  // correct order
              && *this != SubsequenceIterator<T, Compare>(); // end not yet reached
        previousValue = value;
        return *this;
    }

    SubsequenceIterator operator++(int)
    {
        SubsequenceIterator tmp = *this;
        operator++();
        return tmp;
    }

    bool sorted() const { return sorted_;}

    /* When the end of a subsequence was recognized, the internal flag
       for this can be reset with nextSubsequence() in order to
       process the next subsequence (if there is one): */

    void nextSubsequence()
    {
        sorted_ = (*this != SubsequenceIterator<T, Compare>());
    }

    Compare Compareobject() const { return comp;}

    /* Compareobject() supplies a copy of the internal comp object. In
       addition to the inherited variables, the following ones are
       needed: */

  private:
    Compare comp;
    bool sorted_;
    T previousValue;
};


// SubSeqIterator is a placeholder for the data type of a subsequence iterator.
template<class SubSeqIterator>
void split(SubSeqIterator& InputIterator,
              const char *Filename1,
              const char *Filename2,
              bool& sorted)
{
    ofstream Target1(Filename1);
    ofstream Target2(Filename2);
    typedef typename SubSeqIterator::value_type value_type;

    ostream_iterator<value_type> Output1(Target1, "\n");
    ostream_iterator<value_type> Output2(Target2, "\n");
    SubSeqIterator End;

    /* The functioning is quite simple: as long as the input stream
       supplies a sorted subsequence, all data is written to an output
       stream. Once the end of a sorted subsequence is reached,
       flipflop is used to switch to the other output stream. In order
       to save the caller unnecessary work, the variable sorted
       remembers whether there has been any violation of the sorting
       order in the input stream. */

    sorted = true;
    bool flipflop  = true;

    while(InputIterator != End)
    {
       while(InputIterator.sorted())
          if(flipflop) *Output1++ =  *InputIterator++;
          else         *Output2++ =  *InputIterator++;

       if(InputIterator != End)
       {
          sorted = false;
          flipflop = !flipflop;
          InputIterator.nextSubsequence();
       }
    }
}

/* After splitting a file into two temporary auxiliary files, the file
   is rebuilt on a `higher sorting level' by merging the auxiliary
   files.*/

template <class SubsequenceIterator, class OutputIterator,
          class Compare>
void mergeSubsequences(SubsequenceIterator first1,
                       SubsequenceIterator last1,
                       SubsequenceIterator first2,
                       SubsequenceIterator last2,
                       OutputIterator result,
                       const Compare& comp)
{
    // as long as not both the auxiliary files are exhausted
    while (first1 != last1 && first2 != last2)
    {
        // merge sorted subsequences
        while(first1.sorted() && first2.sorted())
             if (comp(*first1, *first2))
                 *result++ = *first2++;
             else
                 *result++ = *first1++;

        // At this point, (at least) one of the subsequences is terminated.
        // Now copy the rest of the other subsequence:
        while(first1.sorted()) *result++ = *first1++;
        while(first2.sorted()) *result++ = *first2++;

        // Process the next subsequence in both auxiliary files,
        // provided there is one:
        first1.nextSubsequence();
        first2.nextSubsequence();
    }

    // At least one of the temporary files is exhausted. 
    // Copy the rest of the other one:
    copy(first1, last1, result);
    copy(first2, last2, result);
}

/* Next, the function externalSorting() follows, which constitutes the
   user interface in a main() program. */

template<class IstreamIterator, class Compare>
int externalSorting(IstreamIterator& InputIterator,
                    const char *SortFile,
                    const char *Separator,
                    const Compare& comp)
{
    typedef iterator_traits<IstreamIterator>::value_type valueType; 
    bool sorted = false;

    // arbitrary names for auxiliary files
    const char *TempFile1 = "esort001.tmp", 
               *TempFile2 = "esort002.tmp";

    int Run = 0;       // number of sort-merge cycles
    do
    {
       ifstream Inputfile(SortFile);
       SubsequenceIterator<valueType, Compare>
                      FileIterator(Inputfile, comp);

       /* The file to be sorted must exist. A suitable subsequence
          iterator for reading  is passed to the function split()
          which writes sorted subsequences of the main file into two
          auxiliary files. */

       split(FileIterator, TempFile1, TempFile2, sorted);
       Inputfile.close();

       /* During this process, split()} determines whether the input
          is already sorted. Only if this is not the case, are further
          steps necessary. These steps consist in generating
          subsequence iterators for the function mergeSubsequences()
          and opening the output file. Then, the subsequences are
          merged. */

       if(!sorted)
       {
          // prepare for merging
          ifstream Source1(TempFile1);
          ifstream Source2(TempFile2);

          SubsequenceIterator<valueType, Compare> I1(Source1, comp);
          SubsequenceIterator<valueType, Compare> I2(Source2, comp);
          SubsequenceIterator<valueType, Compare> End;

          // open SortFile for writing
          ofstream Outputfile(SortFile);
          ostream_iterator<valueType> Result(Outputfile, Separator);

          mergeSubsequences(I1, End, I2, End, Result, comp);
          ++Run;
       }
    } while(!sorted);
    return Run;
}


#endif

