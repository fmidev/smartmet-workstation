// FmiCombineDataThread.cpp

#include "FmiCombineDataThread.h"
#include "afxmt.h"
#include "NFmiMilliSecondTimer.h"
#include "NFmiHelpDataInfo.h"
#include "NFmiFileString.h"
#include "NFmiFileSystem.h"
#include "NFmiQueryDataUtil.h"
#include "NFmiQueryData.h"
#include "NFmiStreamQueryData.h"
#include "NFmiSoundingIndexCalculator.h"
#include "FmiDataLoadingThread2.h"
#include "catlog/catlog.h"

#include <vector>
#include <thread>
#include "NFmiSettings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static bool gUseDebugLog = false;

static void DebugCombineDataThread(const std::string &theLogStr, CatLog::Severity severity)
{
	if(gUseDebugLog || severity > CatLog::Severity::Debug) // eli jos tästä poikkeava, niin lokita
        CatLog::logMessage(theLogStr, severity, CatLog::Category::Data);
}

namespace
{
	CSemaphore gCombineDataThreadRunning; // tämän avulla yritetään lopettaan jatkuvasti pyörivä working thread 'siististi'
	CSemaphore gSoundingIndexDataThreadRunning; // tämän avulla yritetään lopettaan jatkuvasti pyörivä working thread 'siististi'

	NFmiStopFunctor gCombineDataStopFunctor, gSoundingIndexDataStopFunctor;
	bool gCheckForCombinedDataRebuild; // cache-threadi laittaa tämän flagin päälle, kun se on saanut kopsattua historia datan lokaali cacheen. 
										// Tällöin pitää tarkistaa, voidaanko yhdistelmä data rakentaa täydellisillä tiedoilla.
	int gCombineDataStartUpDelayInMS = 0; // tämän avulla voidaan säätää kuinka kauan alussa odotellaan, ennen kuin tehdään työt ensimmäisen kerran
	int gSoundingIndexStartUpDelayInMS = 0; // tämän avulla voidaan säätää kuinka kauan alussa odotellaan, ennen kuin tehdään työt ensimmäisen kerran

/*
	int gClosingTime = 0; // main-thread ilmoittaa tällä, kun se haluaa lopettaa ohjelman, working threadilla
					// on jonkin aikaa lopettaa omat juttunsa (mutta jos kesken qdatan luvun, ei tätä voi testata)
					// Aluksi arvo nolla. Kun main-thread haluaa lopettaa, asettaa tämän ykköseksi.
					// Sen jälkeen yrittää saada lukkoon tietyn ajan gThreadRunning-semaphorea,
					// jos onnistuu, lopetetaan ohjelma halitusti. Jos se ei onnistu
					// (eli worker tekee datan lukua liian pitkään), main-thread lopettaa väkivaltaisesti.
*/
	// Tietorakenne, missä tarvittavat tiedot datan yhdistämisestä ja hakemistoista ja file-filttereistä
	class DataCombineInfo
	{
	public:
		std::string itsSourceDirectory; // johdettu itsSourceFileFilter:istä
		std::string itsSourceFileFilter; // polkuineen filefilttereineen
		std::string itsTargetDirectory; // johdettu itsTargetFileFilter:istä
		std::string itsTargetFileFilter; // yhdistelmä tiedosto polkuineen ja filefilttereineen. nimessä pitää olla timestamppi minuutteja myöten, aikaleima laitetaan *-merkin tilalle
		int itsMaximumTimeSteps; // kuinka monta aika-askelta kootussa datassa saa maksimissaan olla
	};

	std::vector<DataCombineInfo> gDataCombineInfos;
	CSemaphore gChangeCombineDataSettings; // tämän avulla muutetaan combine-data asetuksia thread-safesty
	std::vector<DataCombineInfo> gMediatorDataCombineInfos; // tätä käytetään kun asetuksia muutetaan ja pitää rakentaa uusi info-setti thread-safesty
	bool gDataCombineSettingsChanged; 

	// Tietorakenne, missä tarvittavat tiedot sounding-index datan tekemisestä ja hakemistoista ja file-filttereistä
	class SoundingIndexDataInfo
	{
	public:
		bool IsNewDataNeeded(void)
		{ // tarkistaa lähdedatoista ja tulosdatoista uusimman tiedoston aikeleiman ja sen perusteella voidaan päätellä 
		  // onko tullut uutta dataa, josta pitää tehdä soundingindex-dataa
			return NFmiFileSystem::NewestPatternFileTime(itsSourceFileFilter) > NFmiFileSystem::NewestPatternFileTime(itsTargetFileFilter);
		}

		std::string itsSourceDirectory; // johdettu itsSourceFileFilter:istä
		std::string itsSourceFileFilter; // polkuineen filefilttereineen
		std::string itsTargetDirectory; // johdettu itsTargetFileFilter:istä
		std::string itsTargetFileFilter; // yhdistelmä tiedosto polkuineen ja filefilttereineen. nimessä pitää olla timestamppi minuutteja myöten, aikaleima laitetaan *-merkin tilalle
        std::string itsRequiredGroundDataFileFilter; // Jos vaaditaan ground dataa laskuihin, tässä pitää olla ei-tyhjä tiedosto file-filter
    };

	std::vector<SoundingIndexDataInfo> gSoundingIndexDataInfos;
}

void CFmiCombineDataThread::SetFirstTimeDelay(int theStartUpDelayInMS)
{
	gCombineDataStartUpDelayInMS = theStartUpDelayInMS;
}

void CFmiSoundingIndexDataThread::SetFirstTimeDelay(int theStartUpDelayInMS)
{
	gSoundingIndexStartUpDelayInMS = theStartUpDelayInMS;
}

static bool LetGoAfterFirstTimeDelaying(NFmiMilliSecondTimer &theTimer, bool theFirstTimeflag, int theDelayTimeInMS)
{
	if(theFirstTimeflag)
	{
		if(theTimer.CurrentTimeDiffInMSeconds() >= theDelayTimeInMS)
			return true;
	}
	return false;
}

void CFmiCombineDataThread::CheckForCombinedDataRebuild(void)
{
	gCheckForCombinedDataRebuild = true;
}

// main-thread kertoo tällä funtiolla, että nyt on aika lopettaa
void CFmiCombineDataThread::CloseNow(void)
{
	gCombineDataStopFunctor.Stop(true);
}

// katsoo saako lukituksi gThreadRunning-semaphoren, jos saa, voidaan lopettaa ohjelma
// kuten haluttiinkin.
// Palauttaa 1 jos homma ok ja voidaan lopettaa.
// Palauttaa 0 jos ei saanut vielä semaphorea haltuunsa.
int CFmiCombineDataThread::WaitToClose(int theMilliSecondsToWait)
{
	CSingleLock singleLock(&gCombineDataThreadRunning);
	if(singleLock.Lock(theMilliSecondsToWait))
		return 1;
	return 0;
}

static std::string GetDirectory(const std::string &theFileFilter)
{
	NFmiFileString fileStr(theFileFilter);
	NFmiString str;
	str += fileStr.Device();
	str += fileStr.Path();

	return static_cast<char*>(str);
}

#ifdef CreateDirectory
#undef CreateDirectory // win32 systeemit määrittelevät CreateDirectory-makron, joka otetaan tässä pois käytöstä varmuuden vuoksi
#endif

static void MakeCombineDataInfos(const NFmiHelpDataInfoSystem &theHelpDataInfoSystem, std::vector<DataCombineInfo> &theDataCombineInfos)
{
	theDataCombineInfos.clear();
	const checkedVector<NFmiHelpDataInfo> &helpDataInfoVector = theHelpDataInfoSystem.DynamicHelpDataInfos();
	for(size_t i = 0; i < helpDataInfoVector.size(); i++)
	{
		const NFmiHelpDataInfo &helpDataInfo = helpDataInfoVector[i];
		if(helpDataInfo.IsEnabled() && helpDataInfo.IsCombineData())
		{ // jos kyseessä oli datatiedostoista koottava data, lisätään se listaan
			DataCombineInfo dataCombineInfo;
			dataCombineInfo.itsMaximumTimeSteps = helpDataInfo.CombineDataMaxTimeSteps();
			dataCombineInfo.itsTargetFileFilter = helpDataInfo.CombineDataPathAndFileName();
			dataCombineInfo.itsTargetDirectory = ::GetDirectory(dataCombineInfo.itsTargetFileFilter);
			dataCombineInfo.itsSourceFileFilter = helpDataInfo.UsedFileNameFilter(theHelpDataInfoSystem);
			dataCombineInfo.itsSourceDirectory = ::GetDirectory(dataCombineInfo.itsSourceFileFilter);
			theDataCombineInfos.push_back(dataCombineInfo);
		}
	}
}

void CFmiCombineDataThread::InitCombineDataInfos(const NFmiHelpDataInfoSystem &theHelpDataInfoSystem)
{
	CSingleLock singleLock(&gChangeCombineDataSettings); // muista että tämä vapauttaa semaphoren kun tuhoutuu
	if(singleLock.Lock(3000)) // Attempt to lock the shared resource, 3000 means 3 sec wait
	{
		::MakeCombineDataInfos(theHelpDataInfoSystem, gMediatorDataCombineInfos);
		gDataCombineSettingsChanged = true;
	}
}

static void ApplyCombineDataInfoSettings(void)
{
	if(gDataCombineSettingsChanged)
	{
		CSingleLock singleLock(&gChangeCombineDataSettings); // muista että tämä vapauttaa semaphoren kun tuhoutuu
		if(singleLock.Lock(3000)) // Attempt to lock the shared resource, 3000 means 3 sec wait
		{
			gDataCombineInfos.swap(gMediatorDataCombineInfos);
			gMediatorDataCombineInfos.clear();
			gDataCombineSettingsChanged = false;
		}
	}
}

static void	DoCombinationWork(bool fDoRebuildCheck)
{
	::ApplyCombineDataInfoSettings(); // aina kierroksen aluksi kokeillaan tarvitseeko asetuksia päivittää...

	// 1. käy läpi kaikki tarkasteltavat hakemistot, ja tutki onko niihin ilmestynyt uusia datatiedostoja
	//	- kumpaa aikaleimaa pitää tarkastella cache-hakiksen viimeisintä vai lahde hakemiston viimeisintä
	//  - jos useita SmartMeteja käynnissä, ei ehkä kuin yhden tarvitsisi tehdä yhdistelmä data, 
	//    jos tarkastellaan cache-hakemiston viimeisintä tiedostoa ja verataan sitä lähde-hakemiston viimeiseen
	//		- jos cache-hakis sisältää tuoreemman, ei tehdä mitään!!
	for(size_t i = 0; i < gDataCombineInfos.size(); i++)
	{
		DataCombineInfo &combinedDataInfo = gDataCombineInfos[i];
		NFmiQueryDataUtil::CheckIfStopped(&gCombineDataStopFunctor);
        ::DebugCombineDataThread(std::string("Checking if data combination is needed from directories:\n") + combinedDataInfo.itsSourceDirectory + std::string(" and ") + combinedDataInfo.itsTargetDirectory, CatLog::Severity::Debug);
//		if(NFmiFileSystem::NewestFileTime(combinedDataInfo.itsSourceDirectory) > NFmiFileSystem::NewestFileTime(combinedDataInfo.itsTargetDirectory))
		if(fDoRebuildCheck || NFmiFileSystem::NewestPatternFileTime(combinedDataInfo.itsSourceFileFilter) > NFmiFileSystem::NewestPatternFileTime(combinedDataInfo.itsTargetFileFilter))
		{
            ::DebugCombineDataThread(std::string("Starting doing combine data from directory: ") + combinedDataInfo.itsSourceDirectory, CatLog::Severity::Debug);
	// 2. jos on, niin tee yhdistely 
			try
			{
                std::unique_ptr<NFmiQueryData> data(NFmiQueryDataUtil::CombineQueryDatas(fDoRebuildCheck, combinedDataInfo.itsTargetFileFilter, combinedDataInfo.itsSourceFileFilter, true, combinedDataInfo.itsMaximumTimeSteps, &gCombineDataStopFunctor)); // true = tehdään aika-askel yhdisteltyä dataa
                if(data)
                {
                    // varmistetaan että kohda hakemisto on olemassa
                    NFmiFileSystem::CreateDirectory(combinedDataInfo.itsTargetDirectory);
                    // 3. tarkista ensin että ja talleta queryData tiedostoon oikeaan cache-hakemistoon, mutta väärällä nimellä ja lopuksi tee rename jolloin tiedosto on halutun niminen
                    std::string outputFileName = combinedDataInfo.itsTargetFileFilter;
                    NFmiStaticTime currentTime;
                    std::string timeStampStr = static_cast<char*>(currentTime.ToStr(kYYYYMMDDHHMM)); // tehdään minuutin tarkkuudella aikaleima, tällöin jos toinen käynnissä oleva SmartMet tekee jo ennenmin tiedoston, tätä ei tarvitse tallentaa
                    NFmiStringTools::ReplaceAll(outputFileName, "*", timeStampStr);
                    std::string tmpOutputFileName = outputFileName + "_TMP_FILE_DELETE_THIS_";

                    if(NFmiFileSystem::FileExists(outputFileName) == false && NFmiFileSystem::FileExists(tmpOutputFileName) == false)
                    {
                        ::DebugCombineDataThread(std::string("Storing data to file: ") + tmpOutputFileName, CatLog::Severity::Debug);
                        NFmiStreamQueryData sQueryData;
                        sQueryData.WriteData(tmpOutputFileName, data.get(), static_cast<long>(data->InfoVersion()));
                        if(NFmiFileSystem::FileExists(outputFileName) == false)
                        {
                            NFmiFileSystem::RenameFile(tmpOutputFileName, outputFileName);
                            ::DebugCombineDataThread(std::string("renaming to final data-file: ") + outputFileName, CatLog::Severity::Debug);
                            CFmiDataLoadingThread2::LoadDataNow(); // laitetaan tietoa data-loading threadille että on tullut uutta dataa
                        }
                        else
                        { // jos sinne on nyt ilmestynyt saman niminen tiedosto, poistetaan väliaikainen tiedosto, joka ehdittiin tallentaa
                            NFmiFileSystem::RemoveFile(tmpOutputFileName);
                            ::DebugCombineDataThread(std::string("Removing temporary file because final data-file allready exist: ") + outputFileName, CatLog::Severity::Debug);
                        }

                        // siivotaan hakemistoa aina kun lisätään tiedostoja
                        double maxFileAgeInHours = 1;
                        if(data->Info()->TimeResolution() > 0)
                            maxFileAgeInHours = data->Info()->TimeResolution() * 4.2 / 60.; // yritetään tehdä niin pitkä ikääntymis aika, että 4 tiedostoa jää
                        NFmiFileSystem::CleanDirectory(combinedDataInfo.itsTargetDirectory, maxFileAgeInHours); // tuhotaan tuntia vanhemmat tiedostot, ei voida käyttää fileFilter siivousta, tällöin hakemistoon jäisi mahdolliset tmp-tiedostot
                        NFmiFileSystem::CleanFilePattern(combinedDataInfo.itsTargetFileFilter, 3); // tuhotaan vielä muut paitsi 3 viimaistä tiedostoa, jotka osuvat filefilteriin
                    }
                    else
                    {
                        ::DebugCombineDataThread(std::string("Not storing the data, all ready exist?: ") + outputFileName, CatLog::Severity::Debug);
                        // siellä oli jo sen niminen tiedosto, oletetaan että toinen SmartMet teki sen juuri, eikä tehdä mitään
                    }
                }
                else
                    ::DebugCombineDataThread(std::string("Unable to create the combined data"), CatLog::Severity::Debug);
            }
			catch(NFmiStopThreadException & /* e */ )
			{
				return ; // aika lopettaa threadi
			}
			catch(...)
			{ // tämä oli joku muu 'normaali' virhe
				continue; // jatketaan for-looppia
			}
		}
	}
}

UINT CFmiCombineDataThread::DoThread(LPVOID /* pParam */)
{
	gCheckForCombinedDataRebuild = false;

    ::DebugCombineDataThread("CFmiCombineDataThread::DoThread - starting combineData-thread.", CatLog::Severity::Debug);

	CSingleLock singleLock(&gCombineDataThreadRunning); // muista että tämä vapauttaa semaphoren kun tuhoutuu
	if(!singleLock.Lock(5000)) // Attempt to lock the shared resource, 5000 means 5 sec wait, 0 wait resulted sometimes to wait for next minute for unknown reason
	{
//		doc->LogMessage("CFmiCombineDataThread::DoThread oli jo lukittuna, lopetetaan...", Info);
		return 1;
	}

	NFmiMilliSecondTimer timer;
	bool firstTime = true;

	// Tässä on iki-looppi, jossa vahditaan onko tullut uusia datoja, jolloin tehdään yhdistelmä datoja SmartMetin luettavaksi.
	// Lisäksi pitää tarkkailla, onko tullut lopetus käsky, joloin pitää siivota ja lopettaa.
	int counter = 0;
	try
	{
		for( ; ; counter++)
		{
			NFmiQueryDataUtil::CheckIfStopped(&gCombineDataStopFunctor);
			bool localDoRebuildCheckFlag = 	gCheckForCombinedDataRebuild; // tehdään rebuild-check lokaalin muuttujan kautta, että DoCombinationWork-funktiossa ei aloiteta sitä kesken kierroksen (jonka lopuksi lippu laitetaan sitten pois päältä)

			if(localDoRebuildCheckFlag || ::LetGoAfterFirstTimeDelaying(timer, firstTime, gCombineDataStartUpDelayInMS) || timer.CurrentTimeDiffInMSeconds() > (30 * 1000))
			{ // jos on kulunut tarpeeksi aikaa, tarkastetaan, onko jonnekin tullut uusia datatiedostoja jotka pitää yhdistää
				firstTime = false;
				try
				{
					::DoCombinationWork(localDoRebuildCheckFlag);
				}
				catch(NFmiStopThreadException & /* e */ )
				{
					return 0;
				}
				catch(...)
				{
					// tämä oli joku 'tavallinen' virhe tilanne,
					// jatketaan vain loopitusta
				}
				if(localDoRebuildCheckFlag)
					gCheckForCombinedDataRebuild = false; // tässä on varmistettu, että lippua ei aseteta ennen kuin kaikki datat on käyty läpi
				timer.StartTimer(); // aloitetaan taas uusi ajan lasku
			}
			else
			{
				if(counter%15 == 0)
					::DebugCombineDataThread("CFmiCombineDataThread::DoThread - do nothing (report every 15th time)...", CatLog::Severity::Debug);
			}

			NFmiQueryDataUtil::CheckIfStopped(&gCombineDataStopFunctor);
			Sleep(1*1000); // nukutaan aina lyhyitä aikoja (1 s), että osataan tutkia usein, joska pääohjelma haluaa jo sulkea
		}
	}
	catch(...)
	{
		// tämä oli luultavasti StopThreadException, lopetetaan joka tapauksessa
	}

    return 0;   // thread completed successfully
}

// **********************************************************************
// CFmiSoundingIndexDataThread-namespaceen liittyvät jutut
// **********************************************************************

static void MakeSoundingIndexBasePathWarning(bool baseSoundingIndexDirectoryStringEmpty, const std::string &sourceDataFileFilter)
{
    static const std::string warningStr = "Neither 'soundingIndexBasePath' nor 'dataPath4' were not set in configurations.\nSoundingIndex data is set to be generated and it'll be stored to root directory.\nFollowing data generates soundingIndex data:\n";
    static const std::string warningTitleStr = "soundingIndex data path warning";

    if(baseSoundingIndexDirectoryStringEmpty)
    {
        CatLog::logMessage(warningStr + sourceDataFileFilter, CatLog::Severity::Warning, CatLog::Category::Data);
    }
}


// Tätä initialisointi funktiota pitää kutsua ennen kuin itse threadi käynnistetään. Tämä lisää
// luettavia datoja NFmiHelpInfoDataSystem:iin.
void CFmiSoundingIndexDataThread::InitSoundingIndexDataInfos(NFmiHelpDataInfoSystem &theHelpDataInfoSystem, const std::string &autoGeneratedSoundingIndexBasePath)
{
	gSoundingIndexDataInfos.clear();
	std::string cacheBaseDir = autoGeneratedSoundingIndexBasePath;
    bool baseDirStringEmpty = cacheBaseDir.empty();
	cacheBaseDir += kFmiDirectorySeparator;
	std::string extraName = "_soundingIndex"; // tämä lisätään cache hakemiston ja tiedoston nimeen.

	const checkedVector<NFmiHelpDataInfo> &helpDataInfoVector = theHelpDataInfoSystem.DynamicHelpDataInfos();
	checkedVector<NFmiHelpDataInfo> newHelpDataInfos; // tähän lisätään uudet datat, jotka pitää rekisteröidä
	for(size_t i = 0; i < helpDataInfoVector.size(); i++)
	{
		const NFmiHelpDataInfo &helpDataInfo = helpDataInfoVector[i];
		if(helpDataInfo.IsEnabled() && helpDataInfo.MakeSoundingIndexData())
		{ // jos halutaan että datasta tehdään soundingIndex-dataa, lisätään se listaan
			SoundingIndexDataInfo soundIndexInfo;
			soundIndexInfo.itsSourceFileFilter = helpDataInfo.UsedFileNameFilter(theHelpDataInfoSystem);
			soundIndexInfo.itsSourceDirectory = ::GetDirectory(soundIndexInfo.itsSourceFileFilter);
            ::MakeSoundingIndexBasePathWarning(baseDirStringEmpty, soundIndexInfo.itsSourceFileFilter);

			// tee target hakemistot ja filefilterit automaattisesti (missä rekisteröidään ne luettaviksi infoOrganizeriin???, pitäisikö tämä luoda GenDocin init:issä?)
			soundIndexInfo.itsTargetDirectory = cacheBaseDir + helpDataInfo.Name() + extraName;

			soundIndexInfo.itsTargetFileFilter = soundIndexInfo.itsTargetDirectory;
			soundIndexInfo.itsTargetFileFilter += kFmiDirectorySeparator;
			soundIndexInfo.itsTargetFileFilter += "*_" + helpDataInfo.Name() + extraName + ".sqd";
            if(!helpDataInfo.RequiredGroundDataFileFilterForSoundingIndexCalculations().empty())
            {
                auto groundDataHelpInfo = theHelpDataInfoSystem.FindHelpDataInfo(helpDataInfo.RequiredGroundDataFileFilterForSoundingIndexCalculations());
                if(groundDataHelpInfo)
                {
                    soundIndexInfo.itsRequiredGroundDataFileFilter = groundDataHelpInfo->UsedFileNameFilter(theHelpDataInfoSystem);;
                }
            }

			gSoundingIndexDataInfos.push_back(soundIndexInfo);

			// Lisäksi luodut data pitää rekisteröidä, että SmartMet lukee ne normaali käytännön mukaisesti.
			// Lisätään ne listaan ensin ja lopuksi lisätään ne kerralla HelpDataInfoSystem:iin.
			NFmiHelpDataInfo hInfo;
			hInfo.Name(helpDataInfo.Name() + extraName);
			hInfo.FileNameFilter(soundIndexInfo.itsTargetFileFilter, true); // tämä taitaa olla ainoa tilanne kun force laitetaan päälle
			hInfo.DataType(static_cast<NFmiInfoData::Type>(NFmiInfoData::kModelHelpData));
//			hInfo.DataType(static_cast<NFmiInfoData::Type>(NFmiInfoData::kSoundingParameterData + helpDataInfo.DataType())); // Tämä on ikävä jäänne vanhasta tavasta laskea lennossa indeksejä, jos en tee tätä samoin 
//																					// kuin ennen, eivät jo luodut näyttömakrot toimi näiden kanssa enää. Tekisi mieli tehdä tämä toisin...
			newHelpDataInfos.push_back(hInfo);
		}
	}
	// rekiteröidään uudet datat
	for(size_t j = 0; j < newHelpDataInfos.size(); j++)
        theHelpDataInfoSystem.AddDynamic(newHelpDataInfos[j]);
}

void CFmiSoundingIndexDataThread::CloseNow(void)
{
	gSoundingIndexDataStopFunctor.Stop(true);
}

int CFmiSoundingIndexDataThread::WaitToClose(int theMilliSecondsToWait)
{
	CSingleLock singleLock(&gSoundingIndexDataThreadRunning);
	if(singleLock.Lock(theMilliSecondsToWait))
		return 1;
	return 0;
}

static void	DoSoundingIndexDataWork()
{
    // Jos koneessa on liian vähän ytimiä, ei kannata jakaa laskuja useampaan säikeeseen
	bool useOnlyOneThread = std::thread::hardware_concurrency() < 4; 

	// 1. käy läpi kaikki tarkasteltavat infodatat, ja tutki, onko jossain qDatassa tuoreempi aikaleima kuin sitä vastaavassa soundingDatassa
	//  - jos useita SmartMeteja käynnissä, ei ehkä kuin yhden tarvitsisi tehdä yhdistelmä data, 
	//    jos tarkastellaan cache-hakemiston viimeisintä tiedostoa ja verrataan sitä lähde-hakemiston viimeiseen
	//		- jos cache-hakis sisältää tuoreemman, ei tehdä mitään!!
	// TODO soundingIndex datojea voisi myös päivittää, kun tulee uutta mesa analyysejä ja havaintoja, jolloin niille ajoille voisi laskea havaintojen avulla tietyt parametrit uudestaan
	for(size_t i = 0; i < gSoundingIndexDataInfos.size(); i++)
	{
		SoundingIndexDataInfo &dataInfo = gSoundingIndexDataInfos[i];
		NFmiQueryDataUtil::CheckIfStopped(&gSoundingIndexDataStopFunctor);
        ::DebugCombineDataThread(std::string("Checking if soundingIndexData making is needed from directories:\n") + dataInfo.itsSourceDirectory + std::string(" and ") + dataInfo.itsTargetDirectory, CatLog::Severity::Debug);
		if(dataInfo.IsNewDataNeeded())
		{
            CatLog::logMessage(std::string("Starting doing soundingIndex data from: ") + dataInfo.itsSourceFileFilter, CatLog::Severity::Debug, CatLog::Category::Data);
			NFmiMilliSecondTimer debugTimer;
			debugTimer.StartTimer();
	// 2. tee sounding index data
			boost::shared_ptr<NFmiQueryData> data;
			try
			{
				std::string producerNameStr; // TODO: laita tähän kuvaava nimi
                int maxUsedThreads = FmiRound(boost::thread::hardware_concurrency() * 0.3); // otetaan käyttöön n. 1/3 säikeistä
				data = NFmiSoundingIndexCalculator::CreateNewSoundingIndexData(dataInfo.itsSourceFileFilter, producerNameStr, dataInfo.itsRequiredGroundDataFileFilter, false, &gSoundingIndexDataStopFunctor, useOnlyOneThread, maxUsedThreads);
				debugTimer.StopTimer();
			}
			catch(NFmiStopThreadException & /* e */ )
			{
				return ; // aika lopettaa threadi
			}
			catch(std::exception &e)
			{ 
                // tämä oli joku raportoitava virhe
                CatLog::Severity usedLogLevel = CatLog::Severity::Error;
                std::string exceptionMessage = e.what();
                if(exceptionMessage.find(NFmiSoundingIndexCalculator::itsReadCompatibleGroundData_functionName) != std::string::npos)
                    usedLogLevel = CatLog::Severity::Debug;
                CatLog::logMessage(std::string("DoSoundingIndexDataWork: ") + exceptionMessage, usedLogLevel, CatLog::Category::Data);
				continue; // jatketaan for-looppia
			}
			catch(...)
			{ // tämä oli joku muu 'normaali' virhe
                CatLog::logMessage("DoSoundingIndexDataWork: unknown problem", CatLog::Severity::Error, CatLog::Category::Data);
				continue; // jatketaan for-looppia
			}

			if(data)
			{
				{
					std::string debugStr("Making ");
					debugStr += dataInfo.itsTargetDirectory;
					debugStr += " \ndata lasted ";
					debugStr += debugTimer.EasyTimeDiffStr();
                    CatLog::logMessage(debugStr, CatLog::Severity::Debug, CatLog::Category::Data);
				}

				// varmistetaan että kohde hakemisto on olemassa
				NFmiFileSystem::CreateDirectory(dataInfo.itsTargetDirectory);
			// 3. tarkista ensin että ja talleta queryData tiedostoon oikeaan cache-hakemistoon, mutta väärällä nimellä ja lopuksi tee rename jolloin tiedosto on halutun niminen
				std::string outputFileName = dataInfo.itsTargetFileFilter;
				NFmiStaticTime currentTime;
				std::string timeStampStr = static_cast<char*>(currentTime.ToStr(kYYYYMMDDHHMM)); // tehdään minuutin tarkkuudella aikaleima, tällöin jos toinen käynnissä oleva SmartMet tekee jo ennenmin tiedoston, tätä ei tarvitse tallentaa
				NFmiStringTools::ReplaceAll(outputFileName, "*", timeStampStr);
				std::string tmpOutputFileName = outputFileName + "_TMP_FILE_DELETE_THIS_";

				if(NFmiFileSystem::FileExists(outputFileName) == false && NFmiFileSystem::FileExists(tmpOutputFileName) == false)
				{
                    ::DebugCombineDataThread(std::string("finished doing soundingIndex data from: ") + dataInfo.itsSourceFileFilter, CatLog::Severity::Info);
                    ::DebugCombineDataThread(std::string("Storing soundingIndex-data to file: ") + tmpOutputFileName, CatLog::Severity::Debug);
					NFmiStreamQueryData sQueryData;
					sQueryData.WriteData(tmpOutputFileName, data.get(), static_cast<long>(data->InfoVersion()));
					if(NFmiFileSystem::FileExists(outputFileName) == false)
					{
						NFmiFileSystem::RenameFile(tmpOutputFileName, outputFileName);
                        ::DebugCombineDataThread(std::string("renaming to final soundingIndexData-file: ") + outputFileName, CatLog::Severity::Debug);
						CFmiDataLoadingThread2::LoadDataNow(); // laitetaan tietoa data-loading threadille että on tullut uutta dataa
					}
					else
					{ // jos sinne on nyt ilmestynyt saman niminen tiedosto, poistetaan väliaikainen tiedosto, joka ehdittiin tallentaa
						NFmiFileSystem::RemoveFile(tmpOutputFileName);
                        ::DebugCombineDataThread(std::string("Removing temporary file because final soundingIndexData-file allready exist: ") + outputFileName, CatLog::Severity::Debug);
					}

					// siivotaan hakemistoa aina kun lisätään tiedostoja
					double maxFileAgeInHours = 13;
					NFmiFileSystem::CleanDirectory(dataInfo.itsTargetDirectory, maxFileAgeInHours); // tuhotaan tuntia vanhemmat tiedostot, ei voida käyttää fileFilter siivousta, tällöin hakemistoon jäisi mahdolliset tmp-tiedostot
				}
				else
				{
                    ::DebugCombineDataThread(std::string("Not storing the soundingIndexData, all ready exist?: ") + outputFileName, CatLog::Severity::Debug);
					// siellä oli jo sen niminen tiedosto, oletetaan että toinen SmartMet teki sen juuri, eikä tehdä mitään
				}
			}
			else
                ::DebugCombineDataThread(std::string("Unable to create the soundingIndexData from: ") + dataInfo.itsSourceFileFilter, CatLog::Severity::Info);
		}
	}
}

UINT CFmiSoundingIndexDataThread::DoThread(LPVOID /* pParam */ )
{
	::DebugCombineDataThread("CFmiSoundingIndexDataThread::DoThread - starting soundingIndexData-thread.", CatLog::Severity::Debug);

	CSingleLock singleLock(&gSoundingIndexDataThreadRunning); // muista että tämä vapauttaa semaphoren kun tuhoutuu
	if(!singleLock.Lock(5000)) // Attempt to lock the shared resource, 5000 means 5 sec wait, 0 wait resulted sometimes to wait for next minute for unknown reason
	{
        ::DebugCombineDataThread("CFmiSoundingIndexDataThread::DoThread oli jo lukittuna, lopetetaan...", CatLog::Severity::Debug);
		return 1;
	}

	if(gSoundingIndexDataInfos.size() == 0)
	{
        ::DebugCombineDataThread("CFmiSoundingIndexDataThread::DoThread - there were no data registered to work with, ending thread.", CatLog::Severity::Debug);
		return 0;
	}

	NFmiMilliSecondTimer timer;
	bool firstTime = true;

	// Tässä on iki-looppi, jossa vahditaan onko tullut uusia datoja, jolloin tehdään soundingIndex-datoja SmartMetin luettavaksi.
	// Lisäksi pitää tarkkailla, onko tullut lopetus käsky, joloin pitää siivota ja lopettaa.
	int counter = 0;
	try
	{
		for( ; ; counter++)
		{
			NFmiQueryDataUtil::CheckIfStopped(&gSoundingIndexDataStopFunctor);

			if(::LetGoAfterFirstTimeDelaying(timer, firstTime, gSoundingIndexStartUpDelayInMS) || timer.CurrentTimeDiffInMSeconds() > (60 * 1000))
			{ // jos on kulunut tarpeeksi aikaa, tarkastetaan, onko jonnekin tullut uusia datatiedostoja jotka pitää yhdistää
				firstTime = false;
				try
				{
					DoSoundingIndexDataWork();
				}
				catch(NFmiStopThreadException & /* e */ )
				{
					return 0;
				}
				catch(...)
				{
					// tämä oli joku 'tavallinen' virhe tilanne,
					// jatketaan vain loopitusta
				}

				timer.StartTimer(); // aloitetaan taas uusi ajan lasku
			}
			else
			{
				if(counter%30 == 0)
                    ::DebugCombineDataThread("CFmiSoundingIndexDataThread::DoThread - do nothing (report every 15th time)...", CatLog::Severity::Debug);
			}

			NFmiQueryDataUtil::CheckIfStopped(&gSoundingIndexDataStopFunctor);
			Sleep(1*1000); // nukutaan aina lyhyitä aikoja (1 s), että osataan tutkia usein, joska pääohjelma haluaa jo sulkea
		}
	}
	catch(...)
	{
		// tämä oli luultavasti StopThreadException, lopetetaan joka tapauksessa
	}

    return 0;   // thread completed successfully
}


